\documentclass{article}

\usepackage{fontspec}
\setmainfont[Mapping=tex-text]{AR PL UMing TW}
%\setmainfont[Mapping=tex-text]{文泉驛正黑}
\XeTeXlinebreaklocale ``zh''
\XeTeXlinebreakskip = 0pt plus 1pt

\usepackage{amsmath}
\usepackage{multirow}

\def\tac{\textasciicircum}
\title{瑲珩}
\author{王湘叡}

\begin{document}
\maketitle{}

在開始之前，讓我們先考慮漢字的``筆劃數''這個屬性。%
假設我們需要知道``曉''這個字的筆劃數，%
最原始的方式是從日的第一筆劃開始，一筆劃一筆劃地去描繪，直到兀的最後一筆。%
在邊寫的同時邊計數，最後得到共十六劃。%

但另一個方法則是：\\
考慮到\\
\[
  \mbox{``曉''}=\mbox{``日''}+\mbox{``堯''}
\]
如果事先已經知道``日''為四劃及``堯''為十二劃，則只要用加法運算就可得到十六劃了。%
然而問題是：要怎麼才可以事先知道``日''、``堯''的筆劃數呢？%
看起來，似乎還是要一筆劃一筆劃去地去計算。
但我們一樣可以採用類似的步驟。
因為\\
\[
  \mbox{``堯''}=\mbox{``垚''}+\mbox{``兀''}
\]
也就是如果事先已經知道``垚''為九劃和``兀''為三劃，則用加法就可得到十二劃。
而要計算``垚''的筆劃，
考慮到\\
\[
  \mbox{``垚''}=\mbox{``土''}\times 3
\]
也就是，如果事先已經知道``土''為三劃，則只要用乘法就可得到``垚''為九劃。
於是，最後的問題變成：要怎麼才可以事先知道``土''、``兀''和``日''的筆劃數呢？
這沒有其它方法，只能用一筆劃一筆劃去地去計算。

從另一個角度來想：
只要我們用一筆劃一筆劃地去計算``土''、``兀''和``日''的筆劃數，
而不用一筆劃一筆劃地去描繪``曉''，
我們就可以計算出``曉''的筆劃數。

看起來，這個方法未必會比一筆劃一筆劃地去計算``曉''的筆劃數來得快，
（因為要一筆劃一筆劃地去計算``土''、``兀''和``日''的筆劃數，且還要做一些加法或乘法運算）。
表面上是如此，但這是在``只計算一個字的筆劃數''的情況下才是如此。
如果現在的情況是``要計算一堆字的筆劃數''，
考量到很多部件在中文字是時常出現的，如``土''、``日''等，
則可以省下不少工夫。
以上面例子來說，只要知道``土''、``兀''和``日''的筆劃數，
我們不但在計算過程中得到了``垚'',``堯'',``曉''的筆劃數。
只要再加上一些計算，
我們同樣可以算出``昌'',``昍'',``晶'',``晿'',``圭'',``圼'',``晆'',``曉''等字的筆劃數。


如果我們將類似的原理套用在輸入法上：
只要我們事先知道一些基本或不易分割的部件的外碼（字碼），
並在結合部件時，採用一定的方式去組合外碼，就可以算出那個字的外碼。
我們就可以省下大量的功夫，甚至是用電腦來計算。
%``曉''=``日''+``堯''\\
%``堯''=``垚''+``兀''\\
%``垚''=``土''+``土''+``土''\\
%%``土''，``日''，``垚''，``堯''，``曉''，''兀''
%%``土''，``垚''，``堯''，``曉''，``兀''

\section{用辭說明}
\begin{itemize}
\item 首碼\\
字根的第一個碼。以``靣''來說，在倉頡中拆作``一田口''，首碼即為一\\
\item 次碼\\
字根的第二個碼。以``靣''來說，在倉頡中拆作``一田口''，首碼即為田\\
\item 三碼\\
字根的第三個碼。以``靣''來說，在倉頡中拆作``一田口''，首碼即為口田\\
\item 末碼\\
字根的最後一個碼。以``靣''來說，在倉頡中拆作``一田口''，首碼即為口\\
\item 尾碼\\
在倉頡中，有時取碼時，並不是取字根的最後一碼，而是最後中的特徵碼。\\
為了與末碼區分，稱之為尾碼。以``靣''來說，在倉頡中拆作``一田口''，首碼即為田
 
\item 簡碼\\
\item 快碼\\
將較常出現的字以較短的編碼來指定者稱之。
將較常出現的字根以較短的編碼來指定者稱之。
如，

\item 標準編碼\\
根據輸入法規則而得到的編碼。

\item 容錯編碼\\
輸入法為了讓使用者有更好的體驗，
為了預防使用者選用不同的字集，為拆碼見解不同於標準，
所以提供多種編碼。

\item 多碼\\
一個字在同一種輸入法下可以有兩種以上的編碼。不同於容錯編碼的概念。\\
      容錯編碼基本上是不標準的碼，如字形不同。但此指的都是標準編碼。
      如注音，一個字可以有很多種唸法，於是，就有多種編碼。
      只要符合規則的，即為標準編碼。
      多碼與容錯編碼間有模糊地帶。

%\item 重碼\\
%不同的字，卻有相同的編碼，稱為重碼。重碼的比率稱為重碼率。\\
%
\end{itemize}


\section{行列、大易}
行列、大易的規則皆為前三後一。

同樣也是以``曉''為例。
\begin{tabular}{llll}
字  & 行列碼 & 大易碼\\
日  & P(0\tac) & D\\
土  & R(4\tac) & F\\
垚  & RRR(4\tac4\tac4\tac) & FFF\\
兀  & AS(1-2-) & EQ\\
堯  & RRRS(4\tac4\tac4\tac2-) & FFFQ\\
曉  & PRRS(0\tac4\tac4\tac2-) & DFFQ\\
\end{tabular}

使用``$\mbox{字}_{\mbox{行列碼}}$''來表示一個字的行列碼。
如$\mbox{``曉''}_{\mbox{行列碼}}$=``PRRS''。
使用``$\mbox{字}_{\mbox{大易碼}}$''來表示一個字的大易碼。
如$\mbox{``曉''}_{\mbox{大易碼}}$=``DFFQ''。
若$(\mbox{丙}=\mbox{甲}+\mbox{乙})$
我們可以用
\begin{subequations}
  \begin{align}
  \mbox{丙}_{\mbox{行列碼}}&=\mbox{取}_{\mbox{前三後一}}(\mbox{甲}_{\mbox{行列碼}}+\mbox{乙}_{\mbox{行列碼}})\\
  \mbox{丙}_{\mbox{大易碼}}&=\mbox{取}_{\mbox{前三後一}}(\mbox{甲}_{\mbox{大易碼}}+\mbox{乙}_{\mbox{大易碼}})
  \end{align}
\end{subequations}
來計算

\section{嘸蝦米}
嘸蝦米的規則亦為前三後一，但不同的是，嘸蝦米多了一個補碼規定
－－若取碼不足兩碼，則要根據最後一筆劃添加補碼。
為此，為嘸蝦米添加一個屬性：
用``嘸''、``.嘸補'' 表示一個字的嘸蝦米碼和補碼，\\
使用``$\mbox{字}_{\mbox{嘸蝦米補碼}}$''來表示一個字的嘸蝦米補碼。
使用``$\mbox{字}_{\mbox{嘸蝦米碼}}$''來表示一個字的嘸蝦米碼。
$\mbox{``垚''}_{\mbox{嘸}}=YYY$\\
$\mbox{``兀''}_{\mbox{嘸補}}=L$\\
函數``\mbox{補}(X, Y)'' 則會根據 $X$ 的長度是否小於等於二碼來決定是否附加 $Y$
則
\begin{subequations}
  \begin{align}
  \mbox{丙}_{\mbox{嘸蝦米補碼}}&=\mbox{乙}_{\mbox{嘸蝦米補碼}}\\
  \mbox{暫}_{\mbox{嘸蝦米碼}}&=\mbox{取}_{\mbox{前三後一}}(\mbox{甲}_{\mbox{嘸蝦米碼}}+\mbox{乙}_{\mbox{嘸蝦米碼}})\\
  \mbox{丙}_{\mbox{嘸蝦米碼}}&= \left\{\begin{array}{ll}
%        1 & 1\\
%        2 & 1
        \mbox{暫}_{\mbox{嘸蝦米碼}} & \mbox{若$\mbox{暫}_{\mbox{嘸蝦米碼}} \geq $三碼}\\
        \mbox{暫}_{\mbox{嘸蝦米碼}}+\mbox{丙}_{\mbox{嘸蝦米補碼}} & \mbox{若$\mbox{暫}_{\mbox{嘸蝦米碼}} \leq $二碼}
      \end{array}\right.
  \end{align}
\end{subequations}
\section{倉頡}
{\LARGE
注意：這裡使用的方法是有問題的，須對一些字做例外處理：如毈、
主因是：倉頡分割部件的方式，及取碼方式。
}\\

倉頡的規則分為整體字和組合字。
整體字若不足四碼則全取，否則取首、二、三、末碼。
若為組合字，
``倉本''表示當成本字的倉頡碼。
``倉部''表示當成部件的倉頡碼。\\
$\mbox{``垚''}_{\mbox{倉本}}=GGG$\\
$\mbox{``八''}_{\mbox{倉部}}=HO$\\

\begin{subequations}
  \begin{align}
  \mbox{丙}_{\mbox{倉本}}&=\mbox{首尾}(\mbox{甲}_{\mbox{倉部}})
      + \mbox{首二尾}({\mbox{乙}_{\mbox{倉部}}})\\
  \mbox{丙}_{\mbox{倉部}}&= \mbox{首二尾}(
      \mbox{首尾}(\mbox{甲}_{\mbox{倉部}})
      + \mbox{首尾}(\mbox{甲}_{\mbox{倉部}})
      )
  \end{align}
\end{subequations}

\section{鄭碼}
鄭碼的規則有點複雜。首先，鄭碼會定義一些字根，並為每個字根編碼。
到目前為止，還跟其它輸入法類似。不同的是，鄭碼會使用二碼來為字根編碼。
鄭碼的字根大多為二碼字，對一些常用的部件則為一碼。
在少數的情況下，有三碼。
鄭碼會依不同的情況，可以省每略一些部件或位碼。
須要計算部件數，並依其個數，來決定規則。
不過，鄭碼會用到的字根最多只有頭兩個和尾兩個，總共最多四個。
使用``$\mbox{字}_{\mbox{鄭碼字根串列}}$''來表示一個字的字根串列。
如$\mbox{``曉''}_{\mbox{鄭碼字根串列}}=[\mbox{``日''}, \mbox{``土''}, \mbox{``土''}, \mbox{兀}]$\\

因此，有以下特性：
\begin{subequations}
  \begin{align}
  \mbox{丙}_{\mbox{鄭碼字根串列}} &= \mbox{甲}_{\mbox{鄭碼字根串列}} + \mbox{乙}_{\mbox{鄭碼字根串列}} \\
  \end{align}
\end{subequations}

只要為每個字求出其所用到的字根串列，再套用其規則，即可算出鄭碼。
此外，在鄭碼中，區碼的重要性大於位碼，也就是說，在無法全取字根的碼時，會先保留區碼。
如``由''的碼為``KIA''，在遇到``由''這個字根，且只能取一碼時，就取''K''。
且只能取二碼時，就取''KI''。
且只能取三碼時，就取''KIA''。

\begin{tabular}{lcll}
           & 首根碼數 & 規則 & 例字\\
  \multirow{3}{*}{二基根字} & 1 & 首根一碼+末根三碼，若末根只有一碼，則補``VV''\\
  & 2 & 首根二碼+末根二碼\\
  & 3 & 首根三碼+末根一碼\\
  \multirow{3}{*}{三基根字} & 1 & 首根一碼+次末根一碼+末根二碼\\
  & 2 & 首根二碼+次末根一碼+末根一碼\\
  & 3 & 首根三碼+末根一碼\\
  \multirow{4}{*}{四基根字以上} & 1 & 首根一碼+次根一碼+次末根一碼+末根二碼\\
  & 2 & 首根二碼+次末根一碼+末根一碼\\
  & 3 & 首根三碼+末根一碼\\
\end{tabular}

\end{document}
